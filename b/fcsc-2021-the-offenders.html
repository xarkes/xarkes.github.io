<!DOCTYPE html><html lang=en><head><title>FCSC 2021 - The Offenders writeup</title><meta charset=UTF-8><meta name=viewport content="width=device-width"><link rel=stylesheet type=text/css href=/static/css/style.css><link rel=stylesheet type=text/css href=/static/css/native.css></head><body><main><nav><ul><li><a href=/ >index</a></li><li><a href=/b>blog</a></li><li><a href=https://github.com/xarkes>git</a></li><li><a href=https://twitter.com/xarkes_>twitter</a></li></ul></nav><article><h1><a href=/b/fcsc-2021-the-offenders.html>FCSC 2021 - The Offenders writeup</a></h1><p class=meta>Published on 03 May 2021</p><p>In the context of the <a href=https://ecsc.eu/ >European Cyber Security Challenge</a> the <a href=https://en.wikipedia.org/wiki/Agence_nationale_de_la_s%C3%A9curit%C3%A9_des_syst%C3%A8mes_d%27information>ANSSI</a> organised qualifications named <a href=https://france-cybersecurity-challenge.fr/ >FCSC</a> in order to select the team that would represent France. I managed to take a look at some challenges, in particular "The Offenders" which deals about Windows Defender. This writeup will show my quick and dirty way of solving it.</p><h2>Overview</h2><p>The challenge provides us a <code>PE32+</code> executable and explains it was found on VirusTotal and expects to be run by Windows Defender.</p><p>After opening the executable in a decompiler, I observed that the main function does the following:</p><ol><li>Fetches names for some running processes</li><li>Fetches files from the filesystem (e.g. <code>C:\mirc\mirc.ini</code>)</li><li>Fetches some Windows registry keys</li></ol><p>Then it mixes the data altogether and finally xor it with the string <code>INPUTINPUTINPUTINPUTINPUTINPU</code> and then xor it again with some constants. Finally, if the input data (originally <code>INPUTINPUT...</code>) starts with <code>FCSC{</code> and the resulting data of the previous operations is equal to the string <code>"Reminder: patch CVE-2021-1647"</code>, then it will create a file and write <code>Congratz</code> inside.</p><p>Thus we have the following equation:</p><div class=codehilite><pre><span></span><code><span class=n>fingerprint</span> <span class=o>^</span> <span class=n>input</span> <span class=o>^</span> <span class=n>constants</span> <span class=o>=</span> <span class=n>cve_string</span>
</code></pre></div><p>From what we've seen, we know <code>input</code> should contain the flag, so if we can manage to get the fingerprinting data, we can retrieve the flag thanks to the nature of the xor operation:</p><div class=codehilite><pre><span></span><code><span class=n>input</span> <span class=o>=</span> <span class=n>cve_string</span> <span class=o>^</span> <span class=n>constants</span> <span class=o>^</span> <span class=n>fingerprint</span>
</code></pre></div><p>From there I tried to think of the fastest way to solve this (i.e. to retrieve the <code>fingerprint</code> information) and it seemed obvious to me that we would have to dump it from a Windows Defender process.</p><h2>Executing Windows Defender</h2><p>When looking around on the internet, we can see that <a href=https://twitter.com/taviso>Tavis Ormandy</a> made a tool <a href=https://github.com/taviso/loadlibrary>mpclient</a> which allows us to debug the Windows Defender engine (<code>mpengine.dll</code>) from a Linux environment. This sounds pretty cool, and after reading the readme we can start downloading a <code>mpam-fe.exe</code> file from Microsoft website and extract it to retrieve an up-to-date <code>mpengine.dll</code> with a few <code>.vdm</code> files which are required by mpclient.</p><p>But how does Windows Defender work after all? The talk <a href=https://i.blackhat.com/us-18/Thu-August-9/us-18-Bulazel-Windows-Offender-Reverse-Engineering-Windows-Defenders-Antivirus-Emulator.pdf>Windows Offender: Reverse Engineering Windows Defender's Antivirus Emulator</a> from <a href=https://twitter.com/0xAlexei>Alexei Bulazel</a> teaches us that Windows Defender will (among a lot of others things - by the way, you should really watch the <a href="https://www.youtube.com/watch?v=wDNQ-8aWLO0">talk</a>) emulate the executable it analyses.</p><p>The strategy I had in mind at this point was to select a specific instruction that is easily recognisable and not executed often, put a breakpoint in Windows Defender's emulation of that instruction, patch our <code>the_offenders.exe</code> binary to insert this instruction right after the fingerprinting, and finally dump the content from memory.</p><p>In order to analyse the <code>mpengine.dll</code> and find the proper instruction handler to break to, it would be very helpful to have symbols. However the latest downloaded <code>mpengine.dll</code> did not have any public symbols on Microsoft Servers.</p><p>Thanks to <a href=https://web.archive.org/ >Web Archive</a> I was however able to download an older version of <code>mpam-fe.exe</code> that would give me an <code>mpengine.dll</code> with its <code>.vdm</code> files so that I can execute it with <code>mpclient</code> and also have the <code>.pdb</code> debug information file from Microsoft Servers. Here is the link for Windows Defender 1.321.1276.0 (engine 1.1.17300.4) from August 2020: <a href=http://web.archive.org/web/20200813073837if_/https://definitionupdates.microsoft.com/download/DefinitionUpdates/VersionedSignatures/AM/1.321.1276.0/x86/mpam-fe.exe>web archive definitionsupdates.microsoft.com</a>.</p><h2>Breaking at the right spot</h2><p>I arbitrarily decided to use the <code>cpuid</code> instruction as I knew it wouldn't be executed often.</p><p><img alt="Windows Defender CPUID's emulation function" src=/static/img/windows_defender_cpuid_emulation.png></p><p>The above picture shows the function responsible for emulating CPUID in <code>mpengine.dll</code>. From this context we can understand it will check the emulated binary <code>rax</code> register with the various parameters the <a href=https://www.felixcloutier.com/x86/cpuid>CPUID</a> instruction takes into account. Note that <code>mpclient</code> runs only in 32 bits with a 32 bits version of <code>mpengine.dll</code>, but Windows Defender can emulate various architectures so it's not a problem that our binary <code>the_offenders.exe</code> is a x64 binary. This value is loaded from <code>esi+0x130</code>. With a bit of luck, this is the location where all the emulated registers are.</p><p>We can confirm this by putting a breakpoint in <code>mpengine.dll</code> while executing it with <code>mpclient</code> at the location of the CPUID emulation. We patch <code>the_offenders.exe</code> by putting anywhere the instructions <code>mov rax, 0x1337; cpuid</code> and we break in the CPUID handler in gdb:</p><div class=codehilite><pre><span></span><code><span class=n>gdb</span> <span class=o>./</span><span class=n>mpclient</span>
<span class=o>...</span>
<span class=p>(</span><span class=n>gdb</span><span class=p>)</span> <span class=n>r</span> <span class=o>/</span><span class=n>share</span><span class=o>/</span><span class=n>the_offenders</span><span class=o>.</span><span class=n>exe</span>
<span class=n>Starting</span> <span class=n>program</span><span class=p>:</span> <span class=o>/</span><span class=n>home</span><span class=o>/</span><span class=n>ubuntu</span><span class=o>/</span><span class=n>fcsc</span><span class=o>/</span><span class=n>loadlibrary</span><span class=o>/</span><span class=n>mpclient</span> <span class=o>/</span><span class=n>share</span><span class=o>/</span><span class=n>the_offenders</span><span class=o>.</span><span class=n>exe</span>
<span class=n>mpclient</span><span class=p>:</span> <span class=n>large</span> <span class=n>number</span> <span class=n>of</span> <span class=n>extra</span> <span class=n>symbols</span> <span class=ow>in</span> <span class=n>engine</span><span class=o>/</span><span class=n>mpengine</span><span class=o>.</span><span class=n>map</span><span class=p>,</span> <span class=n>increase</span> <span class=n>MAX_EXTRA_EXPORTS</span> <span class=ow>and</span> <span class=n>rebuild</span><span class=p>:</span> <span class=n>No</span> <span class=n>such</span> <span class=n>process</span>
<span class=n>main</span><span class=p>():</span> <span class=n>GDB</span><span class=p>:</span> <span class=n>add</span><span class=o>-</span><span class=n>symbol</span><span class=o>-</span><span class=n>file</span> <span class=n>engine</span><span class=o>/</span><span class=n>mpengine</span><span class=o>.</span><span class=n>dll</span> <span class=mh>0x5a100000</span><span class=o>+</span><span class=mh>0x1000</span>
<span class=n>main</span><span class=p>():</span> <span class=n>GDB</span><span class=p>:</span> <span class=n>shell</span> <span class=n>bash</span> <span class=n>genmapsym</span><span class=o>.</span><span class=n>sh</span> <span class=mh>0x5a100000</span><span class=o>+</span><span class=mh>0x1000</span> <span class=n>symbols_1769</span><span class=o>.</span><span class=n>o</span> <span class=o>&lt;</span> <span class=n>engine</span><span class=o>/</span><span class=n>mpengine</span><span class=o>.</span><span class=n>map</span>
<span class=n>main</span><span class=p>():</span> <span class=n>GDB</span><span class=p>:</span> <span class=n>add</span><span class=o>-</span><span class=n>symbol</span><span class=o>-</span><span class=n>file</span> <span class=n>symbols_1769</span><span class=o>.</span><span class=n>o</span> <span class=mi>0</span>

<span class=n>Program</span> <span class=n>received</span> <span class=k>signal</span> <span class=n>SIGTRAP</span><span class=p>,</span> <span class=n>Trace</span><span class=o>/</span><span class=k>breakpoint</span> <span class=n>trap</span><span class=o>.</span>
<span class=o>...</span>

<span class=p>(</span><span class=n>gdb</span><span class=p>)</span> <span class=n>b</span> <span class=o>*</span><span class=mh>0x5a100000</span> <span class=o>+</span> <span class=mh>0x1000</span> <span class=o>+</span> <span class=mh>0x7c3434</span>
<span class=p>(</span><span class=n>gdb</span><span class=p>)</span> <span class=n>display</span> <span class=o>**</span><span class=p>(</span><span class=n>uint64_t</span><span class=o>*</span><span class=p>)(</span><span class=o>$</span><span class=n>esi</span><span class=o>+</span><span class=mh>0x130</span><span class=p>)</span>
<span class=p>(</span><span class=n>gdb</span><span class=p>)</span> <span class=k>continue</span>
</code></pre></div><p>We can hit continue multiple times until the displayed value becomes the value we've set for <code>rax</code> in <code>the_offenders.exe</code>, being <code>0x1337</code>.</p><div class=codehilite><pre><span></span><code>Continuing.

Breakpoint 1, 0x5a8c4434 in ?? ()
1: **(uint64_t*)($esi+0x130) = 0x1337

(gdb) x/10gx *($esi+0x130)
0x5813a328: 0x0000000000001337  0x000000000012f5ec
0x5813a338: 0x0000000140021000  0x0000000000141f30
0x5813a348: 0x000000000012eea0  0x000000000012fff0
0x5813a358: 0x0000000000430000  0x000000000012ff58
0x5813a368: 0x000000000000001d  0x0000000000000000
</code></pre></div><p>We can confirm we can break at a chosen location in the binary and control the registers data.</p><h2>Dumping the memory</h2><p>All we want is the content of the <code>fingerprint</code> buffer, right before it is being xored.</p><div class=codehilite><pre><span></span><code><span class=mf>0</span><span class=n>x140001B46</span>    <span class=n>mov</span>     <span class=n>r8d</span><span class=p>,</span> <span class=mf>1</span><span class=n>Dh</span>
<span class=mf>0</span><span class=n>x140001B4C</span>    <span class=n>lea</span>     <span class=n>rdx</span><span class=p>,</span> <span class=err>[</span><span class=n>rsp</span><span class=o>+</span><span class=mf>10</span><span class=n>D8h</span><span class=o>+</span><span class=n>fingerprint</span><span class=err>]</span>
<span class=mf>0</span><span class=n>x140001B54</span>    <span class=n>lea</span>     <span class=n>rcx</span><span class=p>,</span> <span class=err>[</span><span class=n>rsp</span><span class=o>+</span><span class=mf>10</span><span class=n>D8h</span><span class=o>+</span><span class=n>registry_info</span><span class=err>]</span>
<span class=mf>0</span><span class=n>x140001B5C</span>    <span class=n>call</span>    <span class=n>sub_140002310</span>
<span class=mf>0</span><span class=n>x140001B61</span>    <span class=n>mov</span>     <span class=n>r8d</span><span class=p>,</span> <span class=mf>1</span><span class=n>Dh</span>
<span class=mf>0</span><span class=n>x140001B67</span>    <span class=n>lea</span>     <span class=n>rdx</span><span class=p>,</span> <span class=kr>INPUT</span>      <span class=p>;</span> <span class=s>&quot;INPUTINPUTINPUTINPUTINPUTINPU&quot;</span>
<span class=mf>0</span><span class=n>x140001B6E</span>    <span class=n>lea</span>     <span class=n>rcx</span><span class=p>,</span> <span class=err>[</span><span class=n>rsp</span><span class=o>+</span><span class=mf>10</span><span class=n>D8h</span><span class=o>+</span><span class=n>fingerprint</span><span class=err>]</span>
<span class=mf>0</span><span class=n>x140001B76</span>    <span class=n>call</span>    <span class=n>xor</span>                                               <span class=p>;</span> <span class=n>Xor</span> <span class=n>starts</span> <span class=n>here</span><span class=p>,</span> <span class=kr>print</span> <span class=n>the</span> <span class=nb>val</span><span class=n>ue</span> <span class=n>before</span>
<span class=mf>0</span><span class=n>x140001B7B</span>    <span class=n>mov</span>     <span class=n>r8d</span><span class=p>,</span> <span class=mf>1</span><span class=n>Dh</span>
<span class=mf>0</span><span class=n>x140001B81</span>    <span class=n>lea</span>     <span class=n>rdx</span><span class=p>,</span> <span class=nb>tab</span>
<span class=mf>0</span><span class=n>x140001B88</span>    <span class=n>lea</span>     <span class=n>rcx</span><span class=p>,</span> <span class=err>[</span><span class=n>rsp</span><span class=o>+</span><span class=mf>10</span><span class=n>D8h</span><span class=o>+</span><span class=n>fingerprint</span><span class=err>]</span>
<span class=mf>0</span><span class=n>x140001B90</span>    <span class=n>call</span>    <span class=n>xor</span>
<span class=mf>0</span><span class=n>x140001B95</span>    <span class=n>mov</span>     <span class=n>r8d</span><span class=p>,</span> <span class=mf>5</span>          <span class=p>;</span> <span class=n>MaxCount</span>
<span class=mf>0</span><span class=n>x140001B9B</span>    <span class=n>lea</span>     <span class=n>rdx</span><span class=p>,</span> <span class=kr>INPUT</span>      <span class=p>;</span> <span class=s>&quot;INPUTINPUTINPUTINPUTINPUTINPU&quot;</span>
<span class=mf>0</span><span class=n>x140001BA2</span>    <span class=n>lea</span>     <span class=n>rcx</span><span class=p>,</span> <span class=n>Str1</span>       <span class=p>;</span> <span class=s>&quot;FCSC{&quot;</span>
<span class=mf>0</span><span class=n>x140001BA9</span>    <span class=n>call</span>    <span class=n>strncmp</span>
</code></pre></div><p>We know the <code>fingerprint</code> data will be located in the <code>rcx</code> register if we stop at address <code>0x140001b76</code>, so we can patch there with instructions that will load the content of the buffer at <code>rcx</code> into the various registers to dump the buffer content. It can be done quickly with <a href=https://github.com/rizinorg/rizin>Rizin</a>:</p><div class=codehilite><pre><span></span><code><span class=err>$</span><span class=w> </span><span class=n>rizin</span><span class=w> </span><span class=o>-</span><span class=n>s</span><span class=w> </span><span class=mh>0x140001b76</span><span class=w> </span><span class=o>-</span><span class=n>w</span><span class=w> </span><span class=o>-</span><span class=n>qc</span><span class=w> </span><span class=s1>&#39;&quot;wa mov rax, 0x1337; mov rbx, [rcx]; mov rdx, [rcx+8];</span>
<span class=s1>mov rdi, [rcx+10]; mov rsi, [rcx+0x18]; cpuid;&quot;; pd 15 @ 0x140001b76-8&#39;</span><span class=w> </span><span class=n>the_offenders</span><span class=p>.</span><span class=n>exe</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001b6e</span><span class=w>      </span><span class=n>lea</span><span class=w>   </span><span class=n>rcx</span><span class=p>,</span><span class=w> </span><span class=o>[</span><span class=n>rsp + 0x730</span><span class=o>]</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001b76</span><span class=w>      </span><span class=n>mov</span><span class=w>   </span><span class=n>rax</span><span class=p>,</span><span class=w> </span><span class=mh>0x1337</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001b7d</span><span class=w>      </span><span class=n>mov</span><span class=w>   </span><span class=n>rbx</span><span class=p>,</span><span class=w> </span><span class=n>qword</span><span class=w> </span><span class=o>[</span><span class=n>rcx</span><span class=o>]</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001b80</span><span class=w>      </span><span class=n>mov</span><span class=w>   </span><span class=n>rdx</span><span class=p>,</span><span class=w> </span><span class=n>qword</span><span class=w> </span><span class=o>[</span><span class=n>rcx + 8</span><span class=o>]</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001b84</span><span class=w>      </span><span class=n>mov</span><span class=w>   </span><span class=n>rdi</span><span class=p>,</span><span class=w> </span><span class=n>qword</span><span class=w> </span><span class=o>[</span><span class=n>rcx + 0xa</span><span class=o>]</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001b88</span><span class=w>      </span><span class=n>mov</span><span class=w>   </span><span class=n>rsi</span><span class=p>,</span><span class=w> </span><span class=n>qword</span><span class=w> </span><span class=o>[</span><span class=n>rcx + 0x18</span><span class=o>]</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001b8c</span><span class=w>      </span><span class=n>cpuid</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001b8e</span><span class=w>      </span><span class=k>add</span><span class=w>   </span><span class=n>byte</span><span class=w> </span><span class=o>[</span><span class=n>rax</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>al</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001b90</span><span class=w>      </span><span class=k>call</span><span class=w>  </span><span class=mh>0x1400024a0</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001b95</span><span class=w>      </span><span class=n>mov</span><span class=w>   </span><span class=n>r8d</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001b9b</span><span class=w>      </span><span class=n>lea</span><span class=w>   </span><span class=n>rdx</span><span class=p>,</span><span class=w> </span><span class=nf>str</span><span class=p>.</span><span class=n>INPUTINPUTINPUTINPUTINPUTINPU</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=k>section</span><span class=p>..</span><span class=k>data</span><span class=w></span>
<span class=w>                                                                       </span><span class=p>;</span><span class=w> </span><span class=mh>0x140021000</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=ss>&quot;INPUTINPUTINPUTINPUTINPUTINPU&quot;</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001ba2</span><span class=w>      </span><span class=n>lea</span><span class=w>   </span><span class=n>rcx</span><span class=p>,</span><span class=w> </span><span class=nf>str</span><span class=p>.</span><span class=n>FCSC</span><span class=w>                       </span><span class=p>;</span><span class=w> </span><span class=mh>0x1400163e4</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=ss>&quot;FCSC{&quot;</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001ba9</span><span class=w>      </span><span class=k>call</span><span class=w>  </span><span class=mh>0x140006520</span><span class=w></span>
<span class=w>            </span><span class=mh>0x140001bae</span><span class=w>      </span><span class=n>test</span><span class=w>  </span><span class=n>eax</span><span class=p>,</span><span class=w> </span><span class=n>eax</span><span class=w></span>
<span class=w>        </span><span class=err>┌─</span><span class=o>&lt;</span><span class=w> </span><span class=mh>0x140001bb0</span><span class=w>      </span><span class=n>jne</span><span class=w>   </span><span class=mh>0x140001c3e</span><span class=w></span>
</code></pre></div><p>The rest of the instructions after CPUID are invalid (i.e. <code>add byte [rax], al</code> won't work as <code>rax</code> which will contain <code>0x1337</code> won't be a valid address) but that's not our concern since we don't continue the emulation after CPUID anyways.</p><p>We can start over the debugging session, and dump the needed values after our cpuid instruction is reached:</p><div class=codehilite><pre><span></span><code>(gdb) x/10gx *($esi+0x130)
0x5813a328: 0x0000000000001337  0x000000000012f5d0
0x5813a338: 0x0855b177c6dcd598  0xd7008c6d417553ad
0x5813a348: 0x000000000012eea0  0x000000000012fff0
0x5813a358: 0x0000001d7f00323d  0xa4f60855b177c6dc
0x5813a368: 0x000000000000001d  0x0000000000000000
</code></pre></div><p>Hmm well, it seems hard to understand which value corresponds to what, but with a simple trick we can know which offset represents which register.</p><div class=codehilite><pre><span></span><code>$ rizin -s 0x140001b61 -w -qc <span class=s1>&#39;&quot;wa mov rax, 0x1337; mov rbx, 0x4242; mov rcx, 0x4343;</span>
<span class=s1>mov rdx, 0x4444; mov rdi, 0x4545; mov rsi, 0x4646; cpuid;&quot;; pd 20 @ 0x140001b6e-18&#39;</span> the_offenders.exe
$ gdb ./mpclient

...

<span class=o>(</span>gdb<span class=o>)</span> x/10gx *<span class=o>(</span><span class=nv>$esi</span>+0x130<span class=o>)</span>
0x5813a328: 0x0000000000001337  0x0000000000004343
0x5813a338: 0x0000000000004444  0x0000000000004242
0x5813a348: 0x000000000012eea0  0x000000000012fff0
0x5813a358: 0x0000000000004646  0x0000000000004545
0x5813a368: 0x000000000012f840  0x0000000000000000
</code></pre></div><p>All we have to do now is to build a tiny script to xor everything up, and retrieve the flag:</p><div class=codehilite><pre><span></span><code><span class=ch>#!/usr/bin/env python3</span>

<span class=kn>import</span> <span class=nn>struct</span>

<span class=n>p64</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>struct</span><span class=o>.</span><span class=n>pack</span><span class=p>(</span><span class=s1>&#39;&lt;Q&#39;</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>

<span class=c1># Constants in the binary</span>
<span class=n>cve_string</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;Reminder: patch CVE-2021-1647&#39;</span>
<span class=n>constants</span> <span class=o>=</span> <span class=p>[</span><span class=mh>0xB9</span><span class=p>,</span> <span class=mh>0x75</span><span class=p>,</span> <span class=mh>0x4B</span><span class=p>,</span> <span class=mh>0x6B</span><span class=p>,</span> <span class=mh>0x78</span><span class=p>,</span> <span class=mh>0xA0</span><span class=p>,</span> <span class=mh>0x00</span><span class=p>,</span> <span class=mh>0xC9</span><span class=p>,</span> <span class=mh>0xCE</span><span class=p>,</span> <span class=mh>0x9A</span><span class=p>,</span> <span class=mh>0xEA</span><span class=p>,</span> <span class=mh>0xD5</span><span class=p>,</span> <span class=mh>0x6C</span><span class=p>,</span> <span class=mh>0xBF</span><span class=p>,</span> <span class=mh>0x78</span><span class=p>,</span> <span class=mh>0x45</span><span class=p>,</span> <span class=mh>0xC0</span><span class=p>,</span> <span class=mh>0x9E</span><span class=p>,</span> <span class=mh>0xE4</span><span class=p>,</span> <span class=mh>0x7C</span><span class=p>,</span> <span class=mh>0xED</span><span class=p>,</span> <span class=mh>0xCE</span><span class=p>,</span> <span class=mh>0x39</span><span class=p>,</span> <span class=mh>0x46</span><span class=p>,</span> <span class=mh>0x62</span><span class=p>,</span> <span class=mh>0x6F</span><span class=p>,</span> <span class=mh>0x52</span><span class=p>,</span> <span class=mh>0x6A</span><span class=p>,</span> <span class=mh>0x57</span><span class=p>]</span>
<span class=c1># Dumped data from gdb</span>
<span class=n>buf</span> <span class=o>=</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0xd7008c6d417553ad</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x0855b177c6dcd598</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x185c9aba25c0a4f6</span><span class=p>)</span> <span class=o>+</span> <span class=n>p64</span><span class=p>(</span><span class=mh>0x0000001d7f00323d</span><span class=p>)</span>

<span class=n>x</span> <span class=o>=</span> <span class=nb>bytearray</span><span class=p>(</span><span class=mh>0x1d</span><span class=p>)</span>
<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mh>0x1d</span><span class=p>):</span>
    <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>cve_string</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>^</span> <span class=n>constants</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>^</span> <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
<span class=nb>print</span><span class=p>(</span><span class=n>x</span><span class=o>.</span><span class=n>decode</span><span class=p>())</span>
</code></pre></div><div class=codehilite><pre><span></span><code>$ python3 offenders.py
FCSC<span class=o>{</span>HelloFromEmulatedWorld!<span class=o>}</span>
</code></pre></div><p>That's it!</p><h2>Conclusion</h2><p>The challenge was very fun and I learned a lot about Windows Defender even though this writeup is mostly about getting a quick win. There are many different ways of solving it and I hope you enjoyed this one :-)</p><p>Special thanks to the challenge author and the FCSC organisation team!</p></article><hr></main><footer> 2021 - Antide Petit aka <a href=/ >xarkes</a> - <a href=https://creativecommons.org/licenses/by-sa/4.0/ >CC-BY-SA</a> - Made with ❤️ </footer></body></html>