<!doctype html><html lang=en><head><title>Making an in-game Lineage 2 Bot</title><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><link href=/fonts.css rel=stylesheet><link href=/style.css rel=stylesheet><body><main><nav><ul><li><a href=/>/index</a><li><a href=/b/>/blog</a><li><a href=https://github.com/xarkes>/github</a><li><a href=https://x.com/xarkes_>/x</a></ul></nav><div><h1>Making an in-game Lineage 2 Bot</h1><p><strong>Published on 2020-12-30</strong><p>A few months ago I got nostalgic and wanted to try again a little bit of Lineage 2. In the past most servers were filled with tons of bots that would farm in order to either level up, gain money or loot materials useful for crafting equipment.<p>The working and available bots are all non-free (to my knowledge) and most of them are detected by the remote servers as cheating tools!<p>So I decided to make my own bot as I thought the process would be interesting. This blog post presents my approach at making my own bot for Lineage II.</p><span id=continue-reading></span><h2 id=disclaimer>Disclaimer</h2><p>Although Lineage II is a dying MMORPG, botting is tolerated on some servers and forbidden on others as it may be considered as a cheating tool. You may get banned for life if you try such software on some servers.<h2 id=introduction>Introduction</h2><p>If you are not aware of what the concept of botting is, let's describe it before going further. You can get an idea of what a bot is by reading the <a href=https://en.wikipedia.org/wiki/Internet_bot>Wikipedia page</a>.<p>Lineage II is a MMORPG which demands a lot of farming. The main way to level up is to kill monsters, the main way to get money is to kill monsters and the main way to craft better equipment is to kill monsters. This may sound like a boring game but Lineage II offers in my humble opinion a very unique player versus player (PvP) gameplay style that makes the game much more interesting than many other MMORPGs.<p>Because it requires a lot of farming, being able to automate the action of killing monsters helps a lot the player. One can let its character farm during the night and play during the day and get a lot of rewards.<p>The bot I designed will be able to target a nearby monster, attack it and use spells, pickup items and rest when needed.<p>Lineage II is protected with a (probably old) version of WinLicense, so some functions in the executable file may be virtualized but it won't be of any matter to us. Also, game servers use protections like GameGuard, SmartGuard or LameGuard in order to prevent botting, and for some reason my bot is not detected at all by any server I connected to.<p>Lineage II has a lot of public private server emulators and various researches around packet hacking so the overall task was not very hard to achieve as many resources are available online.<h2 id=making-the-bot>Making the bot</h2><h3 id=design-choice>Design choice</h3><p>I can see two different kind of bots. Full Out-of-Game (OOG) bots, and In-Game bots (IG).<p>The difficulty of making an OOG bot is that it requires to reverse engineer, understand and implement the whole client-server protocol (including network encryption). However it may be quite rewarding as then it's possible to run the bot without a copy of the game. That means it will be much lighter and much easier to run multiple instances of the bot.<p>In the case of Lineage II, making an IG bot is much easier as Lineage II is implemented in such way that the client will not predict any action, but only react to what the server sends. That means we can simulate the sending of a packet using the running client, and that's just it, the game client will react to that packet we sent after the server validates (or not) the action. However running an IG bot might be tedious as it will be a little bit intrusive and might trigger anti cheat detections.<p>I decided to go with the IG bot as Lineage II is an old game I suspected if it had any anti-cheat it would not be too hard to bypass.<h3 id=sending-a-specific-packet>Sending a specific packet</h3><h4 id=finding-the-send-packet-function>Finding the send packet function</h4><p>As my purpose was to automate things, my first objective was to send a chosen packet so I could automate single tasks.<p>Lineage II works in a full TCP fashion and connects first to a login server which centralizes multiple game servers. The next steps describe the sending of a packet when already in game and connected to a game server.<p>In order to send a packet, I needed to find the function that would send a packet. The game uses the function <code>send</code> from the native Windows library <code>ws2_32.dll</code>. All I had to do was to set up a breakpoint there, and do an action in game to trigger it. The parameters given to the <code>send</code> function contain the encrypted packet, so we need to check from where the <code>send</code> function is called thanks to the stack frame. From there it is possible to do a bit of reverse engineering and understand what's happening.<p><img alt="Breakpoint at function sending a packet" src=/img/l2bot/x64dbg_send_packet.png><p>The screenshot above shows a call to the send packet function when I type in a message to send in the game chat. The first value on the stack frame is the return address, and the followings are the function arguments. The first argument is a fixed pointer to some data structure which contains the Windows TCP socket. The second argument is a null terminated string for which each character specifies the type of the packet field. In our case (sending a chat message) the packet contains the following arguments:<ul><li>"c" (<code>char</code>) : <code>0x49</code> which corresponds to the packet id "send message",<li>"S" (<code>String</code>) : <code>L"Hello"</code> which is a pointer to a null terminated wide string,<li>"d" (<code>dword</code>) : <code>0x00000000</code> which corresponds to the channel ID.</ul><h4 id=replaying-a-packet>Replaying a packet</h4><p>In order to call the "send packet" function I decided to inject a DLL into the game process that would create a thread and call this very function.<p>The DLL code is rather small:<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span>DWORD SendPacketFP;
</span><span>DWORD(_stdcall* sendPacket)(DWORD FP, </span><span style=color:#b48ead>const char</span><span>* format, ...);
</span><span>
</span><span style=color:#b48ead>#define </span><span>DATA_SEND_ADDR </span><span style=color:#d08770>0x3E3B80          </span><span style=color:#65737e>// Offset of the "send packet" function in engine.dll
</span><span style=color:#b48ead>#define </span><span>DATA_SEND_SOCKET_INFO </span><span style=color:#d08770>0xFD890000 </span><span style=color:#65737e>// Offset of the networking structure
</span><span>
</span><span style=color:#b48ead>void </span><span style=color:#8fa1b3>ProcessAttach</span><span>()
</span><span>{
</span><span>    DWORD EngineDLLBase = (DWORD) </span><span style=color:#bf616a>GetModuleHandle</span><span>(</span><span style=color:#b48ead>L</span><span>"</span><span style=color:#a3be8c>engine.dll</span><span>");
</span><span>
</span><span>    sendPacket = (DWORD(_stdcall *)(DWORD, </span><span style=color:#b48ead>const char</span><span>*, ...)) EngineDLLBase + DATA_SEND_ADDR;
</span><span>    SendPacketFP = DATA_SEND_SOCKET_INFO; </span><span style=color:#65737e>// Pointer to the network structure
</span><span>
</span><span>    </span><span style=color:#b48ead>const char</span><span> format[] = "</span><span style=color:#a3be8c>cSd</span><span>";
</span><span>    </span><span style=color:#b48ead>const </span><span>WCHAR* message = </span><span style=color:#b48ead>L</span><span>"</span><span style=color:#a3be8c>Hello</span><span>";
</span><span>
</span><span>    DWORD parameters[</span><span style=color:#d08770>3</span><span>] = { </span><span style=color:#d08770>0 </span><span>};
</span><span>    parameters[</span><span style=color:#d08770>0</span><span>] = </span><span style=color:#d08770>0x49</span><span>;                 </span><span style=color:#65737e>// Packet ID
</span><span>    parameters[</span><span style=color:#d08770>1</span><span>] = (DWORD) message;      </span><span style=color:#65737e>// Pointer to our message
</span><span>    parameters[</span><span style=color:#d08770>2</span><span>] = </span><span style=color:#d08770>0x00000000</span><span>;           </span><span style=color:#65737e>// General chat ID
</span><span>
</span><span>    </span><span style=color:#bf616a>sendPacket</span><span>(SendPacketFP, format, parameters[</span><span style=color:#d08770>0</span><span>], parameters[</span><span style=color:#d08770>1</span><span>], parameters[</span><span style=color:#d08770>2</span><span>]);
</span><span>}
</span><span>
</span><span>BOOL APIENTRY </span><span style=color:#8fa1b3>DllMain</span><span>( HMODULE </span><span style=color:#bf616a>hModule</span><span>,
</span><span>                       DWORD  </span><span style=color:#bf616a>ul_reason_for_call</span><span>,
</span><span>                       LPVOID lpReserved
</span><span>                     )
</span><span>{
</span><span>    </span><span style=color:#b48ead>switch </span><span>(ul_reason_for_call)
</span><span>    {
</span><span>    </span><span style=color:#b48ead>case</span><span> DLL_PROCESS_ATTACH:
</span><span>        </span><span style=color:#bf616a>CreateThread</span><span>(</span><span style=color:#d08770>NULL</span><span>, </span><span style=color:#d08770>0</span><span>, (LPTHREAD_START_ROUTINE)ProcessAttach, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>NULL</span><span>);
</span><span>        </span><span style=color:#b48ead>break</span><span>;
</span><span>    </span><span style=color:#b48ead>case</span><span> DLL_THREAD_ATTACH:
</span><span>    </span><span style=color:#b48ead>case</span><span> DLL_THREAD_DETACH:
</span><span>    </span><span style=color:#b48ead>case</span><span> DLL_PROCESS_DETACH:
</span><span>        </span><span style=color:#b48ead>break</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#b48ead>return </span><span style=color:#d08770>TRUE</span><span>;
</span><span>}
</span></code></pre><p>There are multiple ways to inject the DLL inside the game process. I decided to make my own injector which is very simple and will:<ul><li><code>OpenProcess</code> the game process <code>l2.exe</code><li>Allocate memory in the game process address space with <code>VirtualAllocEx</code><li>Write the <code>.dll</code> full path with <code>WriteProcessMemory</code> into that space<li>Load the library with <code>CreateRemoteThread</code> which will call <code>LoadLibraryW</code></ul><p>Now when I load the library, a packet is sent to the server and we can observe the result directly in game.<p><img alt="Successful packet sending from a shared library" src=/img/l2bot/lineage2_hello.png><p>That's cool, now I can make actions in the game, but I also need to get information from the surrounding environment.<h4 id=getting-insights-from-the-game>Getting insights from the game</h4><p>In order for the bot to work, it is required to gather information from the game such as player current position, health, inventory, skills, but also nearby entities such as Non Playable Characters (NPCs) or nearby players or monsters.<p>To do so, I can see only two ways: either inspect the game memory, which involves finding the position of all these structures in the game virtual address space, or just parse the received packets from the server as the game client does. I decided to go with the second way, as I thought it would be hard to gather reliably <em>every</em> information I needed with only memory inspection. However on the long run, it might have been easier as tnere would have been no need to understand the client-server protocol.<p>Similarly to what I've done earlier, it's possible to put a breakpoint on the <code>recv</code> function from <code>ws2_32.dll</code> and check the stack frame and try to find which function is calling <code>recv</code>. After that we can try to step over every function until the packet gets decrypted and we can start parsing it.<p>In order to notify my bot that a packet is received, it is required to hook the "receive packet" function so I can dump the packets and then give the execution flow back to the game.<pre class=language-cpp data-lang=cpp style=color:#c0c5ce;background-color:#2b303b><code class=language-cpp data-lang=cpp><span>LPVOID </span><span style=color:#8fa1b3>Hook</span><span>(LPVOID </span><span style=color:#bf616a>functionToHook</span><span>, LPVOID </span><span style=color:#bf616a>myFunction</span><span>, size_t </span><span style=color:#bf616a>size</span><span>)
</span><span>{
</span><span>    DWORD old;
</span><span>    DWORD old2;
</span><span>
</span><span>    </span><span style=color:#65737e>// Allocate memory and copy the old bytes (original instructions) there
</span><span>    oldInstructions = </span><span style=color:#96b5b4>malloc</span><span>(</span><span style=color:#d08770>5 </span><span>+ size);
</span><span>    </span><span style=color:#bf616a>VirtualProtect</span><span>(oldInstructions, size + </span><span style=color:#d08770>5</span><span>, PAGE_EXECUTE_READWRITE, &old);
</span><span>    </span><span style=color:#96b5b4>memcpy</span><span>(oldInstructions, functionToHook, size);
</span><span>
</span><span>    </span><span style=color:#65737e>// Add a jump after the copied bytes from the hooked function
</span><span>    </span><span style=color:#65737e>// to jump back to the rest of that hooked function.
</span><span>    </span><span style=color:#65737e>// This allows that when someone calls oldInstructions, it acts as the original functionToHook
</span><span>    *(BYTE*)((DWORD)oldInstructions + size) = </span><span style=color:#d08770>0xE9</span><span>;
</span><span>    *(DWORD*)((DWORD)oldInstructions + size + </span><span style=color:#d08770>1</span><span>) = (DWORD)((DWORD)functionToHook + size) - (DWORD)((DWORD)oldInstructions + size) - </span><span style=color:#d08770>5</span><span>;
</span><span>
</span><span>    </span><span style=color:#65737e>// Patch the function to hook in order to jump to our own function
</span><span>    </span><span style=color:#bf616a>VirtualProtect</span><span>(functionToHook, </span><span style=color:#d08770>5</span><span>, PAGE_EXECUTE_READWRITE, &old);
</span><span>    *(BYTE*)functionToHook = </span><span style=color:#d08770>0xE9</span><span>;
</span><span>    *(DWORD*)((DWORD)functionToHook + </span><span style=color:#d08770>1</span><span>) = (DWORD)myFunction - (DWORD)functionToHook - </span><span style=color:#d08770>5</span><span>;
</span><span>    </span><span style=color:#bf616a>VirtualProtect</span><span>(functionToHook, </span><span style=color:#d08770>5</span><span>, old, &old2);
</span><span>    </span><span style=color:#b48ead>return</span><span> oldInstructions;
</span><span>}
</span></code></pre><p>In the function above you might wonder what <code>5</code> refers to, it's actually the length of the <code>jmp</code> instruction.<p>In order to understand the packets and their meaning, there are tons of resources online describing the packets for almost every version of Lineage II, so the reverse engineering task here is almost non-existent.<h3 id=bot-architecture>Bot Architecture</h3><h4 id=software-design>Software design</h4><p>Now that I am able to receive a packet and send a packet to the game, I decided to come up with the following architecture:<p><img alt="L2Bot software architecture" src=/img/l2bot/l2bot_software_architecture.png><p>As seen in the picture, I first inject the DLL which will automatically create a named pipe. The pipe will be used so that when the game receives a packet, the bot gets notified a packet was received, and similarly when the bot needs to interact and do an action in game, it can send it through this socket.<p>Thanks to this architecture I can seemlessly inject and remove the bot from the game process as well as handling multiple game instances.<p>For the graphical interface, I decided to go with Qt for no specific reason appart that I was already familiar with it.<h4 id=bot-automata>Bot automata</h4><p>In order for the bot to be "smart" I decided to go with a sort of automata which may react to external events. The current automata can be described as follows:<p><img alt="Bot's automaton" src=/img/l2bot/l2bot_automaton.png><p>In reality it is much more complex as many things may happen at any time! For instance, you may reach the <code>Start</code> state with a very low health, and you don't want your character to start hitting monsters with low Health Points (HP) so it is preferable to jump to the <code>Rest</code> state. Also you have to keep in mind that nothing is instantaneous, so many checks must be done very often. When choosing a monster to attack and attacking it, usually when you play for real you do not want to attack a monster that is already attacked by a player. To mimick this behavior, it is important to check at multiple states if the current target is still valid. Also it is important to think about every corner case. The bot might select a monster which has already been one shotted by another player by the time the targeting was done, and you don't want the bot to be blocked in such case, hence my choice of having <code>Choosing</code>, <code>Target</code>, <code>Targeted</code>, <code>Engage</code> and <code>Engaged</code>.<p>So every state will have its own set of checks and do the action only if every check successfuly passed, otherwise it will jump back to <code>Start</code>.<p>When an event is received, for example system messages suchs as "Cannot see target" or "Invalid target", I decided to simply check in what state the automata is and react accordingly.<h2 id=results>Results</h2><p>In the end, the bot works nicely and is not detected by any server I tried even after hours of farming. I managed to run 4 instances simultaneously on the same computer and on the same server for hours without any hassle, while I am aware that other botting tools get detected immediately. This lets me think that every "anti-bot" system that are purchasable online are actually only checking for known bots or signatures and do not even attempt to do some "advanced" analysis.<p>I am aware some server are more sophisticated and ask for a captcha after a certain amount of time, but I think those are custom "home made" protections which might be a bit annoying for the players, but makes it harder for someone who uses a bot to defeat (although I found some working in-game captcha breaker implementations online).<p>That's pretty much it, in the end the bot was quite simple to build and I'm happy with the results even though there is still much to do. However I am afraid my nostalgia has gone and that I won't work much on this little project.<p>You can get the source code on my GitHub repository: <a href=https://github.com/xarkes/L2Bot>https://github.com/xarkes/L2Bot</a>.<p><img alt="Lineage 2 bot GUI" src=/img/l2bot/l2bot_gui.png><p>There are still many things to improve for the bot and if you are interested, you can check it in the next section.<h2 id=going-further>Going further</h2><p>The current bot permits to have something working but nobody likes stupid bots, so below are some features I think would be good to have in order for the bot to be usable in every situation:<ul><li>Add automatic Lineage 2 version detection and proper multiple protocol version support<li>Support automatic spoil and sweep feature<li>Support self buff<li>Support party buff<li>Support items usage (potions, scrolls, ...)<li>Add conditions for item/buff/skill usage<li>Automatically parse game data in order to get and display icons for items, skills, NPC names, etc. <ul><li>Fun fact: <code>.dat</code> files of Lineage 2 are encrypted with RSA which means the client can decrypt it with the public key, and only the game publisher can create a valid <code>.dat</code> file (given that the RSA key is not too weak).<li>Basically it is a signature, however it's <s>dirty</s> funny that they just check if the decryption result is a valid file format</ul><li>Add on death actions (go to town, disconnect, ...)<li>UI improvements (better map resizing, ...)<li>Better party interactions (allow a character to assist another one, to buff, heal, etc. when needed)<li>Add a scripting engine <ul><li>Might be awesome to just record actions to automate some quests, or other various things.</ul><li>Add a "no go" zone feature to avoid obstacles that are obstructing the character line of sight when trying to attack a monster</ul><p>That's it, feel free to reach me if you have any question, I hope you enjoyed!</div></main><footer>2024 - Antide Petit aka <a href=https://xarkes.com>xarkes</a> - <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC-BY-SA</a> - Made with ❤️</footer>